<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[约瑟夫环]]></title>
    <url>%2FJosephus%2F</url>
    <content type="text"><![CDATA[$n$ 个人围成一圈,编号按顺序从 $0$ 到 $n-1$，从第一个人开始报数,数到 $m$ 的人出列,再由下一个人重新从 $1$ 开始报数,数到 $m$ 的人再出圈,……依次类推,直到所有的人都出圈,请输出最后一个出圈的人的编号。 今天稍微学习了一下这个玩意儿，感觉还挺神奇的。 第一种做法：暴力模拟这个我在这就不讲了，很容易就能写出来。 第二种做法：递推我们先考虑第一个出圈的人。 $m &lt; n$ 那么这个人的编号即为 $m - 1$ $m \ge n$ 那么这个人的编号即为 $(m - 1) \bmod n$ 综合一下，第一个出圈的人的编号绝对为 $(m - 1) \bmod n$ 方便起见，我们设 $k - 1 = (m - 1) \bmod n$ 。 于是这个圈就变成了这样： $k \quad k+1 \quad k+2 \quad … \quad n-2 \quad n-1 \quad 0 \quad 1 \quad 2 \quad … \quad k-3 \quad k-2$ 这个时候我们将这个圈转换一下，变成: $0 \quad 1 \quad 2 \quad … \quad n - 3 \quad n - 2$ 可以发现其实这个问题变成了 $n-1$ 个人报数的子问题。 所以我们只要将子问题的答案转换回去，就能知道最后那个人原来的编号。 稍微观察一下如何转换回去: $0 \Rightarrow k$ $1 \Rightarrow k + 1$ $…$ $n - k - 1 \Rightarrow n - 1$ $n - k \Rightarrow 0$ $n - k + 1 \Rightarrow 1$ $…$ $n - 3\Rightarrow k - 3$ $n - 2 \Rightarrow k - 2$ 不难发现 $x$ 转换回去后就变成了 $(x + k) \bmod n$ 我们设 $f[n]$ 表示 $n$ 个人报 $m$ 最后出圈人的编号。 显然，$f[1]=0$ 而根据我们刚才推的公式： $$f[n]=(f[n - 1]+k) \bmod n = (f[n - 1]+m \bmod n) \bmod n = (f[n - 1]+m ) \bmod n$$ 于是就可以愉快的递推了~ 代码1234567int Josephus(int n, int m)&#123; int res = 0; for (int i = 2; i &lt;= n; i ++) res = (res + m) % i; return res;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1074 靶形数独]]></title>
    <url>%2FLuogu_P1074%2F</url>
    <content type="text"><![CDATA[题目描述小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 $Z$ 博士请教，$Z$ 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。 靶形数独的方格同普通数独一样，在 $9$ 格宽 $\times 9$ 格高的大九宫格中有 $9$ 个 $3$ 格宽 $\times 3$ 格高的小九宫格 $($ 用粗黑色线隔开的 $)$。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 $1$ 到 $9$ 的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。$($ 如图 $)$ 上图具体的分值分布是：最里面一格 $($ 黄色区域 $)$ 为 $10$ 分，黄色区域外面的一圈 $($ 红色区域 $)$ 每个格子为 $9 $分，再外面一圈 $($ 蓝色区域 $)$ 每个格子为 $8$ 分，蓝色区域外面一圈 $($ 棕色区域 $)$ 每个格子为 $7$ 分，最外面一圈 $($ 白色区域 $)$ 每个格子为 $6$ 分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独 $($ 每个给定数独可能有不同的填法 $)$，而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和 总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 $2829$ 。游戏规定，将以总分数的高低决出胜负。 输入输出格式输入格式： 一共 $9$ 行。每行 $9$ 个整数 $($ 每个数都在 $0-9$ 的范围内 $)$ ，表示一个尚未填满的数独方格，未填的空格用“ $0$ ”表示。每两个数字之间用一个空格隔开。 输出格式： 输出共 $1$ 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数 $−1$ 。 输入输出样例输入样例#1： 1234567897 0 0 9 0 0 0 0 1 1 0 0 0 0 5 9 0 0 0 0 0 2 0 0 0 8 0 0 0 5 0 2 0 0 0 3 0 0 0 0 0 0 6 4 8 4 1 3 0 0 0 0 0 0 0 0 7 0 0 2 0 9 0 2 0 1 0 6 0 8 0 4 0 8 0 5 0 4 0 1 2 输出样例#1： 12829 输入样例#2： 1234567890 0 0 7 0 2 4 5 3 9 0 0 0 0 8 0 0 0 7 4 0 0 0 5 0 1 0 1 9 5 0 8 0 0 0 0 0 7 0 0 0 0 0 2 5 0 3 0 5 7 9 1 0 8 0 0 0 6 0 1 0 0 0 0 6 0 9 0 0 0 0 1 0 0 0 0 0 0 0 0 6 输出样例#2： 12852 说明【数据范围】 $40\%$ 的数据，数独中非 %0% 数的个数不少于 %30% 。 $80\%$ 的数据，数独中非 %0% 数的个数不少于 %26% 。 $100\%$ 的数据，数独中非 %0% 数的个数不少于 %24% 。 $NOIP\;2009$ 提高组 第四题 题解第一眼就可以看出这是个暴力 $dfs$ 的题目。 但是写起来还是很烦的…第一次写完调好兴奋地交上去 $T$ 了五个点，所以需要一些剪枝。 这个剪枝还是蛮好想的，我们把每一行按照 $0$ 的个数排序，从少到多填，明显会快很多。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;const int score[11][11]=&#123; &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;, &#123;0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0&#125;, &#123;0, 6, 7, 7, 7, 7, 7, 7, 7, 6, 0&#125;, &#123;0, 6, 7, 8, 8, 8, 8, 8, 7, 6, 0&#125;, &#123;0, 6, 7, 8, 9, 9, 9, 8, 7, 6, 0&#125;, &#123;0, 6, 7, 8, 9, 10, 9, 8, 7, 6, 0&#125;, &#123;0, 6, 7, 8, 9, 9, 9, 8, 7, 6, 0&#125;, &#123;0, 6, 7, 8, 8, 8, 8, 8, 7, 6, 0&#125;, &#123;0, 6, 7, 7, 7, 7, 7, 7, 7, 6, 0&#125;, &#123;0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0&#125;, &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;,&#125;;struct h&#123; int data, i; bool operator &lt; (const h &amp;a) const &#123; if(data != a.data) return data &lt; a.data; else return i &lt; a.i; &#125;&#125;tot0[11];int Map[11][11], ans = -1, next[11];bool x[11][11], y[11][11], z[11][11];inline int belong(int a, int b)&#123; return (a - 1) / 3 * 3 + (b - 1) / 3 + 1;&#125;inline void dfs(int a, int b, int s)&#123; if(a == 0) &#123; ans = max(ans, s); return; &#125; if(Map[a][b]) &#123; if(b == 9) &#123; dfs(next[a], 1, s); &#125; else &#123; dfs(a, b + 1, s); &#125; return; &#125; for(register int i = 1; i &lt;= 9; i ++) &#123; if(!x[a][i] &amp;&amp; !y[b][i] &amp;&amp; !z[ belong(a, b) ][i]) &#123; Map[a][b] = i; x[a][i] = y[b][i] = z[ belong(a, b) ][i] = true; if(b == 9) &#123; dfs(next[a], 1, s + score[a][b] * i); &#125; else &#123; dfs(a, b + 1, s + score[a][b] * i); &#125; Map[a][b] = 0; x[a][i] = y[b][i] = z[ belong(a, b) ][i] = false; &#125; &#125; return;&#125;int inline read()&#123; int x = 0, flag = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-')flag = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * flag;&#125;int main()&#123; int tmp = 0; for(register int i = 1; i &lt;= 9; i ++) &#123; tot0[i].i = i; for(register int j = 1; j &lt;= 9; j ++) &#123; Map[i][j] = read(); if(Map[i][j] == 0) &#123; tot0[i].data ++; continue; &#125; x[i][ Map[i][j] ] = true; y[j][ Map[i][j] ] = true; z[ belong(i, j) ][ Map[i][j] ] = true; tmp += Map[i][j] * score[i][j]; &#125; &#125; sort(tot0 + 1, tot0 + 9 + 1); for(register int i = 1; i &lt;= 9; i ++) next[tot0[i].i] = tot0[i + 1].i; dfs(tot0[1].i, 1, tmp); printf("%d", ans); return 0;&#125; 至于为什么码风跟我现在不太一样是因为这是以前写的现在来水篇博客]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妹调玩后感]]></title>
    <url>%2FSister_training_diary%2F</url>
    <content type="text"><![CDATA[此文章已被加密，请输入密码。 Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>二次元</tag>
        <tag>galgame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1191 矩形]]></title>
    <url>%2FLuogu_P1191%2F</url>
    <content type="text"><![CDATA[题目描述给出一个 $n \times n$ 的矩阵，矩阵中，有些格子被染成白色，有些格子被染成黑色，现要求矩阵中白色矩形的数量。 输入输出格式输入格式： 第一行，一个整数 $n$ ，表示矩形的大小。 接下来 $n$ 行，每行 $n$ 个字符，这些字符为“$W$”或“$B$”。其中“$W$”表示白格，“$B$”表示黑格。 输出格式： 一个正整数，为白色矩形数量。 输入输出样例输入样例#1： 123454WWBWBBWBWBWWWBWB 输出样例#1： 115 说明对于 $30\%$ 的数据，$n \leq 50$ ； 对于 $100\%$ 的数据，$n \leq 150$ ； 题解写这道题的题解主要还是为了巩固一下二维前缀和。 为啥这题能用二维前缀和解呢，因为我们可以把这个矩阵看成一个 $01$ 矩阵。 $$\begin{matrix}W&amp;W&amp;B&amp;W\\B&amp;B&amp;W&amp;B\\W&amp;B&amp;W&amp;W\\W&amp;B&amp;W&amp;B\end{matrix} \quad \Rightarrow \quad \begin{matrix}0&amp;0&amp;1&amp;0\\1&amp;1&amp;0&amp;1\\0&amp;1&amp;0&amp;0\\0&amp;1&amp;0&amp;1\end{matrix}$$ 很明显的可以看出，若一个矩阵为白色矩阵，则其包含的数之和为 $0$ 。所以我们可以暴力 $O(n^4)$ 枚举每个矩阵判断。 然而这题能用二维前缀和做的根本原因是数据太水 那么接下来就是二维前缀和的部分。 $sum[n][m]$ 表示左上角为 $(1,1)$ 右下角为 $(n,m)$ 的这个子矩阵中所有数的和。即： $$sum[n][m] = \sum\limits_{i = 1}^{n} \sum\limits_{j = 1}^{m}map[i][j]$$ 易得： $$sum[n][m] = sum [n - 1][m] + sum[n][m - 1] - sum[n - 1][m - 1] + map[n][m]$$ 这个画张图看一看就知道了。 如果想得到左上角为 $(i,j)$ 右下角为 $(k,l)$ 的这个子矩阵中所有数的和： $$ans = sum[k][l] - sum[i - 1][l] - sum[k][j - 1] + sum[i - 1][j - 1]$$ 这个也可以画张图推出来。 于是我们就可以水掉一道蓝题了 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;const int N = 150;int n, ans;int map[N + 5][N + 5];int sum[N + 5][N + 5];void pre()&#123; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= n; j ++) sum[i][j] = sum [i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + map[i][j];&#125;int main()&#123; scanf("%d", &amp;n); char c; for (int i = 1; i &lt;= n; i ++) &#123; for (int j = 1; j &lt;= n; j ++) &#123; std::cin &gt;&gt; c; //输入有坑，可能有空格 map[i][j] = (c == 'B'); &#125; &#125; pre(); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= n; j ++) for (int k = i; k &lt;= n; k ++) for (int l = j; l &lt;= n; l ++) if (sum[k][l] - sum[i - 1][l] - sum[k][j - 1] + sum[i - 1][j - 1] == 0) ans ++; printf("%d", ans); return 0;&#125;]]></content>
      <tags>
        <tag>二维前缀和</tag>
        <tag>暴力</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机动漫图片]]></title>
    <url>%2FRandom_anime_picture%2F</url>
    <content type="text"><![CDATA[无聊的可以来刷一刷 刷出来se图也不能怪我，毕竟是随机的]]></content>
      <tags>
        <tag>二次元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P4931 情侣？给我烧了！（加强版）]]></title>
    <url>%2FLuogu_P4931%2F</url>
    <content type="text"><![CDATA[题目描述有 $n$ 对情侣来到电影院观看电影。在电影院，恰好留有 $n$ 排座位，每排包含 $2$ 个座位，共 $2\times n$ 个座位。 现在，每个人将会随机坐在某一个位置上，且恰好将这 $2\times n$ 个座位坐满。 如果一对情侣坐在了同一排的座位上，那么我们称这对情侣是和睦的。 你的任务是求出共有多少种不同的就坐方案满足恰好有 $k$ 对情侣是和睦的。 两种就坐方案不同当且仅当存在一个人在两种方案中坐在了不同的位置。不难发现，在没有任何限制条件的情况下，每个人任意就坐一共会有 $(2n)!$ 种不同的就坐方案。 输入输出格式输入格式： 输入包含多组数据。 输入的第一行包含一个正整数 $T$ ，表示数据组数。 接下来 $T$ 行，每行包含两个非负整数 $n,k$ ，其意义见题目描述。 输出格式： 对于每组输入数据，输出一行，表示对应的就坐方案数。由于结果可能较大，因此输出对 $998244353$ 取模的结果。 输入输出样例输入样例#1： 12345651 12 02 22333 6662333333 1000000 输出样例#1： 123452168798775522300377435 说明对于 $10\%$ 的数据，满足 $1 \leq T \leq 10,1 \leq n \leq 5$ 对于 $40\%$ 的数据，满足 $1 \leq n \leq 3 \times 10^3$ 对于 $100\%$ 的数据，满足 $1 \leq T \leq 2 \times 10^5,1 \leq n \leq 5 \times 10^6, 0 \leq k \leq n$ 题解这题看上去很难，仔细思考一下的话也不是很复杂。 首先我们要在 $n$ 个情侣中选出 $k$ 对。 $C_n^k$ 然后在在 $n$ 排座位中选出 $k$ 排给这 $k$ 对情侣坐。 $k$ 排可以任意排列。 $C_n^k \times k!=A_n^k$ 每排的 $2$ 个人可以换位置。 $2^k$ 接下来就是最重要的错排部分。 我们令 $f[x]$ 为 $x$ 对情侣不坐在一起的方案数。 很明显第一排 $2$ 个不是情侣的人的坐法是 $2n \times (2n-2)$ 接下来我们考虑第一排坐的 $2$ 个人的情侣 坐在一起，也就是在剩下 $n-1$ 排选一排，转换为剩下 $n-2$ 排情侣需要错排的子问题。注意这两个人是可以换着坐的。 $2 \times (n-1) \times f(n-2)$ 不坐在一起，也就是可以把他们两个看成一对情侣。转换为剩下 $n-1$ 排需要错排的子问题。 $f[n-1]$ 那么我们 $f$ 的公式也就出来了。 $$f[n]=2n \times (2n-2) \times (f[n-1] + 2 \times (n-1) \times f[n-2])$$ 于是结合上面的式子，就可以得到： $$ans=C_n^k \times A_n^k \times 2^k \times f[n-k]$$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;const int p = 998244353;const int N = 5e6;typedef long long ll; int T;ll n, k;ll fac[N + 5], inv_fac[N + 5];ll f[N + 5];ll C(ll n, ll m) // C(n, m) = n! / [(n - m)! * m!] &#123; if (n &lt; m) return 0; return fac[n] * inv_fac[n - m] % p * inv_fac[m] % p;&#125;ll A(ll n, ll m)&#123; return fac[n] * inv_fac[n - m] % p;&#125;ll qpow(ll a, ll b)&#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; &#125; return res;&#125;void pre() // 处理乘法逆元 &amp; 递推f&#123; fac[0] = 1; for (register int i = 1; i &lt;= N; i ++) fac[i] = fac[i - 1] * i % p; inv_fac[0] = inv_fac[1] = 1; for (register int i = 2; i &lt;= N; i ++) inv_fac[i] = (p - p / i) * inv_fac[p % i] % p; for (register int i = 2; i &lt;= N; i ++) inv_fac[i] = inv_fac[i] * inv_fac[i - 1] % p; f[0] = 1, f[1] = 0; for (register int i = 2; i &lt;= N; i ++) f[i] = ((((i - 1) &lt;&lt; 1) % p * f[i - 2] % p + f[i - 1]) % p) * 4 % p * i % p * (i - 1) % p;&#125;int main()&#123; pre(); scanf("%d", &amp;T); while (T --) &#123; scanf("%lld%lld", &amp;n, &amp;k); ll ans = C(n, k) % p; ans = ans * A(n, k) % p; ans = ans * qpow((ll)2, k) % p; ans = ans * f[n - k] % p; printf("%lld\n", ans); &#125;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习]]></title>
    <url>%2FNumber_theory%2F</url>
    <content type="text"><![CDATA[这里会简单记录我学习的基础数论。这里的证明可能都不大严谨，仅供参考。 欧几里得算法如果我们想要求 $gcd(a,b)(a\text{与}b$的最大公因数$)$ ，最简单的方式便是枚举，但这太慢了。 于是我们有了我们的辗转相除法，也就是欧几里得算法，它可以在 $O(log(a+b))$ 的复杂度内求出 $gcd(a,b)$ 。 $$\forall a,b \in \mathbb{N}, b \not = 0,\quad gcd(a,b) = gcd(b,a\bmod b)$$ 证明$a &lt; b$ 时 $gcd(b,a \bmod b)=gcd(b,a)=gcd(a,b)$ $a \geq b$ 时 设 $r=a\bmod b$ ，$d$ 为 $a,\,b$ 任意一个公约数。 则 $a=kb+r,\;a\equiv b\equiv 0 \pmod{d}$ $\therefore a-kb\equiv r \equiv 0 \pmod{d}$ $\therefore d\,|\,b,\,d\,|\,a\bmod b$ 所以 $a,b$ 和 $b, a \bmod b$ 的公约数集合是相同的，它们的最大公约数必然也相等。 $\therefore gcd(a,b)=gcd(b, a \bmod b)$ 要注意边界：$b = 0$ 时，$gcd(a,b) = a$ 代码1234int gcd(int a, int b)&#123; return !b ? a : gcd(b, a % b);&#125; 拓展欧几里得拓展欧几里得用于在已知自然数 $a,b$ ，求解 $ax+by=gcd(a,b)$ 的 $(x,y)$ 的整数解时。 $ax+by=gcd(a,b)$ $=gcd(b,a\bmod b)$ $\Rightarrow bx+(a\bmod b)\,y$ $=bx+(a-\lfloor\dfrac{a}{b}\rfloor\,b)\,y$ $=ay+b\,(x-\lfloor\dfrac{a}{b}\rfloor\,y)$ 所以 $x$ 变成了 $y$ ， $y$ 变成了 $x-\lfloor\dfrac{a}{b}\rfloor\,y$ 于是我们可以愉快地递归求解。这里也需要注意边界： $b=0$ 时，$a=1,\,ax+by=1$ ，因此 $x=1,y=0$ 。 代码1234567void exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x;&#125; 乘法逆元当我们想要求形如 $\dfrac{a}{b} \bmod p$ 的值的时候，就需要用到乘法逆元。 逆元定义 若 $a \times x \equiv 1 \pmod{b}$ ，且 $a \perp b$ ，则我们定义 $x$ 为 $a$ 的逆元 所以对于 $\dfrac{a}{b} \bmod p$ ，我们就可以求出 $b$ 在 $\bmod p$ 意义下的逆元 $x$ ，原分数的值便可以表示为 $a \times x \bmod{p}$ 求解逆元的方法拓展欧几里得这个我们刚刚讲过。这种做法就是将 $a \times x \equiv 1 \pmod {b}$ 转换为 $a \times x + b \times y = 1 $ ，然后求解。 代码1234567891011121314void exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x;&#125;int main()&#123; int x, y; exgcd(a, p, x, y) x = (x + p) % p; // x 就是 a 在 mod p 意义下的逆元&#125; 快速幂 费马小定理：若 $p$ 为质数， $a$ 为正整数， 且 $a \perp p$ ，则有 $a^{p-1} \equiv 1 \pmod{p}$ 所以我们可以进行推导： $a \times x \equiv 1 \equiv a^{p-1} \pmod{p}$ $x \equiv a^{p-2} \pmod{p}$ 因此我们可以用快速幂求出 $a^{p-2} \pmod{p}$ 的值，这个数就是 $a$ 的逆元了。 代码1234567891011121314151617int qpow(int a, int b, int p)&#123; int res = 1; while (b) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; int x = qpow(a, p - 2, p);&#125; 线性递推这个可以用来求一连串数组对于$\bmod p$ 的逆元。 首先我们知道 $1^{-1} \equiv 1 \pmod{p}$ 设 $k = \lfloor\dfrac{p}{i}\rfloor,\,r = p \bmod{i}$ $k \times i + r \equiv 0 \pmod{p}$ 两边同时乘上 $i^{-1},\,r^{-1}$ $k \times r^{-1} + i^{-1} \equiv 0 \pmod{p}$ $i^{-1} \equiv -k \times r^{-1} \pmod{p}$ $i^{-1} \equiv -\lfloor\dfrac{p}{i}\rfloor \times (p \bmod{i})^{-1} \pmod{p}$ 于是我们可以从前推出当前的逆元。 代码123inv[1] = 1;for (int i = 2; i &lt; p; i ++) inv[i] = (p - p / i) * inv[p % i] % p; 阶乘逆元这个一般在求组合数的值得时候用到。比较简单，就一笔带过了。 一般求 $1\text{ ~ }n$ 的阶乘逆元有两种方法： 先求出 $1\text{ ~ }n$ 每个数的逆元，然后正推： $i!^{-1} \equiv (i - 1)! ^ {-1} \times i ^ {-1} \pmod{p}$ 代码12345for (int i = 1; i &lt;= n; i ++)&#123; inv_fac[i] = inv(i); inv_fac[i] = inv_fac[i] * inv_fac[i - 1] % p;&#125; 先求出 $n$ 的阶乘逆元，然后倒推： $i!^{-1} \equiv (i + 1)! ^ {-1} \times (i + 1) \pmod{p}$ 代码123inv_fac[n] = inv(fac[n]);for (int i = n - 1; i &gt;= 1; i --) inv_fac[i] = inv_fac[i + 1] * (i + 1) % p; 欧拉函数$$\varphi(n) = \sum\limits_{i=1}^{n-1} [n \perp i]$$ 通俗的来讲， $\varphi(n)$ 表示小于 $n$ 的正整数当中有多少个数与 $n$ 互质，特别的，我们规定 $\varphi (1)=1$ 这里我们有一个欧拉函数的计算公式； $$\varphi(n) = n \times \prod\limits_{p\,|\,n}(1-\dfrac{1}{p})$$ 证明先咕一会儿，有时间再写。]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增求 $LCA$]]></title>
    <url>%2FLCA%2F</url>
    <content type="text"><![CDATA[好久没有更新了，来写 $(shui)$ 一篇 $LCA$ 的博客。 以前觉得 $LCA$ $($最近公共祖先$)$是神仙学的东西， $fj$ 讲的时候我也贼吉尔懵逼，现在看来也没有那么难。 当我们想求 $LCA(x,y)$ 时，如果一格一格跳直到跳到同一位置，不知道会跳到哪一年去，于是我们用到了一个神奇的东西：倍增。 众所周知任何数都可以用二进制，所以我们可以每次跳 $2^i$ 步，大大加快效率。这里我们用 $fa[i][j]$ 代表第 $i$ 号节点往上跳 $2^j$ 步到达的位置。所以很容易推出来: $fa[i][j]=fa[fa[i][j-1]][j-1]$ 。 然后跳的具体过程看代码。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define For(a,x,y) for(int a=x;a&lt;=y;a++)#define Bac(a,x,y) for(int a=x;a&gt;=y;a--)using namespace std;const int N=5e5;const int M=5e5;int n,m,s;int depth[N+5],fa[N+5][25];int lg[N+5];struct Edge&#123; int to,next;&#125;edge[2*M+5];int num_edge,head[N+5];void add_edge(int from,int to)&#123; edge[++num_edge].next=head[from]; edge[num_edge].to=to; head[from]=num_edge;&#125;int lca(int x,int y)&#123; if(depth[y]&lt;depth[x]) swap(x,y); while(depth[x]&lt;depth[y]) y=fa[y][lg[depth[y]-depth[x]]];//先跳到同一深度 if(x==y)return x; Bac(i,lg[depth[x]],0) &#123; if(fa[x][i]!=fa[y][i])//因为我们要跳到它们LCA的下面一层，所以它们肯定不相等，如果相等就代表跳多了 x=fa[x][i],y=fa[y][i]; &#125; return fa[x][0];&#125;void dfs(int x,int fat)&#123; depth[x]=depth[fat]+1; fa[x][0]=fat; for(int i=1;(1&lt;&lt;i)&lt;=depth[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int p=head[x];p;p=edge[p].next) if(edge[p].to!=fat)dfs(edge[p].to,x);&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); int u,v; For(i,1,n-1) &#123; scanf("%d%d",&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); &#125; lg[0]=-1; For(i,1,n) lg[i]=lg[i/2]+1;//优化，预处理log dfs(s,0); int a,b; For(i,1,m) &#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",lca(a,b)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P3787 冰精冻西瓜]]></title>
    <url>%2FLuogu_P3787%2F</url>
    <content type="text"><![CDATA[题目背景盛夏，冰之妖精琪露诺发现了一大片西瓜地，终于可以吃到美味的冻西瓜啦。 题目描述琪露诺是拥有操纵冷气程度的能力的妖精，一天她发现了一片西瓜地。这里有 $n$ 个西瓜，由 $n-1$ 条西瓜蔓连接，形成一个有根树，琪露诺想要把它们冷冻起来慢慢吃。 这些西瓜蔓具有神奇的性质，可以将经过它的冷气的寒冷程度放大或缩小，每条西瓜蔓放大/缩小冷气寒冷程度的能力值为 $W_i$ ，表示冷气经过它后，寒冷程度值 $x$ 会变为 $x\times w_i$ 。每个西瓜也有一个寒冷程度值，炎热的夏日，所有西瓜的寒冷程度值初始都为 $0$ 。 琪露诺会做出两种动作: ①.对着西瓜 $i$ 放出寒冷程度为 $x$ 的冷气。这股冷气顺着西瓜蔓向“西瓜树”的叶子节点蔓延，冷气的寒冷程度会按照上面的规则变化。遇到一个西瓜连了多条西瓜蔓时，每条叶子节点方向的西瓜蔓均会获得与原先寒冷程度相等的冷气。途径的所有西瓜的寒冷程度值都会加上冷气的寒冷程度值。 ⑨.向你询问西瓜 $i$ 的寒冷程度值是多少。 等等，为什么会有⑨？因为笨蛋琪露诺自己也会忘记放了多少冰呢。 所以，帮她计算的任务就这么交给你啦。 输入输出格式输入格式： 第一行一个整数 $n$ ,表示西瓜的数量。 西瓜编号为 $1\text{ ~ }n$ ， $1$ 为这棵“西瓜树”的根。 接下来 $n-1$ 行，每行有两个整数 $u,v$ 和一个实数 $w$ ，表示西瓜 $u$ 和西瓜 $v$ 之间连接有一条藤蔓，它放大/缩小冷气寒冷程度的能力值为 $w$ 。 接下来一行一个整数 $m$ ，表示操作的数量。 接下来 $m$ 行，每行两个或三个整数。 第一个数只能是 $1$ 或 $9$ 。 如果为 $1$ ，接下来一个整数 $i$ 和一个实数 $x$ ，表示对西瓜 $i$ 放出寒冷程度为 $x$ 的冷气。 如果为 $9$ ，接下来一个整数 $i$ ，表示询问编号为 $i$ 的西瓜的寒冷程度值。 输出格式： 对于每个操作⑨，输出一行一个实数，表示对应西瓜的寒冷程度值。 输入输出样例输入样例#1： 123456789101112131441 2 1.000000002 3 0.000000003 4 1.0000010191 1 3.000000009 29 31 2 1.428560319 49 21 3 4.233333339 29 4 输出样例#1： 1234563.000000000.000000000.000000004.428560314.428560314.23333761 说明子任务可能出现如下的特殊性质: “西瓜树”退化为一条链 输入数据中的实数均保留 $8$ 位小数，选手的答案被判作正确当且仅当输出与标准答案误差不超过 $10^-7$ 。请特别注意浮点数精度问题。 实际数据中，冷气的寒冷程度 $x$ 的范围为 $[-0.1,0.1]$ $($样例中的冷气寒冷程度的范围为 $[1,5]$ $)$ 题解这题还蛮毒瘤的，我交了 $20$ 次才过…$($其实因为我线段树打炸了没发现$)$ 一开始看到这题想到暴力，看到数据立马去世。 于是我想到了线段树。 因为有些边是 $0$ ，我们就把这棵树切成很多棵树遍历。 然后我是这么想的，先把树遍历一下，预处理出每个点到其树根的所有 $w$ 之积 $w[i]$ 。然后假设所有冷气都是由根传来的，那么在第 $i$ 个结点释放 $x$ 的冷气就相当于在根节点释放 $x/w[i]$ 的冷气。 然后接下来只需要区间更新就行了。这里我用了线段树。区间具体是怎么划分的呢？每个点所管辖的区间即是他所有子节点及其本身。我们在遍历的时候可以把 $i$ 所管辖的区间的最后一个数 $right[i]$ 求出来。 查询其实就是单点查询，将该节点的值乘上该节点的 $w[i]$ 就可以了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define N 1000000#define ld long doubleusing namespace std;struct Edge&#123; int from,to,next; ld dis;&#125;edge[N+5];int n,m,num_edge,num_node,num_root;int head[N+5],node[N+5],root[N+5],r[N+5];ld w[N+5],addsum[4*N+5],tree[4*N+5];bool vis[N+5];void add_edge(int from,int to,ld dis)&#123; edge[++num_edge].next=head[from]; edge[num_edge].from=from; edge[num_edge].to=to; edge[num_edge].dis=dis; head[from]=num_edge;&#125;void dfs(int i,ld dis)&#123; if(vis[i])return; vis[i]=true; node[i]=++num_node; w[i]=dis; int p=head[i]; while(p)&#123; if(!edge[p].dis) &#123;if(!vis[edge[p].to])root[++num_root]=edge[p].to;&#125; else dfs(edge[p].to,dis*edge[p].dis); p=edge[p].next; &#125; r[i]=num_node;&#125;void pushdown(int k)&#123; if(!addsum[k])return; addsum[k&lt;&lt;1]+=addsum[k]; addsum[k&lt;&lt;1|1]+=addsum[k]; tree[k&lt;&lt;1]+=addsum[k]; tree[k&lt;&lt;1|1]+=addsum[k]; addsum[k]=0; &#125;ld query(int k,int l,int r,int x)&#123; pushdown(k); if(l==r&amp;&amp;x==l)return tree[k]; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)return query(k&lt;&lt;1,l,mid,x); else return query(k&lt;&lt;1|1,mid+1,r,x);&#125;void add(int k,int l,int r,int x,int y,ld v)&#123; if(l&gt;y||r&lt;x)return; pushdown(k); if(l&gt;=x&amp;&amp;r&lt;=y)&#123; addsum[k]+=v; tree[k]+=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=x)add(k&lt;&lt;1,l,mid,x,y,v); if(mid&lt;y)add(k&lt;&lt;1|1,mid+1,r,x,y,v);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;n;i++)&#123; int u,v; ld d; scanf("%d%d%Lf",&amp;u,&amp;v,&amp;d); add_edge(u,v,d); add_edge(v,u,d); &#125; root[++num_root]=1; for(int i=1;i&lt;=num_root;i++)dfs(root[i],1); scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++)&#123; int k,I; ld x; scanf("%d",&amp;k); if(k==1)&#123; scanf("%d%Lf",&amp;I,&amp;x); add(1,1,n,node[I],r[I],x/w[I]); &#125; else&#123; scanf("%d",&amp;I); printf("%.8Lf\n",query(1,1,n,node[I])*w[I]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2FSegment_tree%2F</url>
    <content type="text"><![CDATA[最近在学线段树。 线段树具有树的结构特征，对于每一个子节点而言，都表示整个序列中的一段子区间；对于每个叶子节点而言，都表示序列中的单个元素信息；子节点不断向自己的父亲节点传递信息，而父节点存储的信息则是他的每一个子节点信息的整合。因此线段树可以处理很多符合结合律的操作。 下面是区间修改区间求值的程序$($我懒得打单点修改区间求值和区间修改单调求值了23333$)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define N 100000#define ll long longusing namespace std;ll n,m,l,r,v,k;ll a[N+5],sum[4*N+5],add[4*N+5];void build(ll k,ll l,ll r)&#123; if(l==r)&#123; sum[k]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); sum[k]=sum[k&lt;&lt;1]+sum[k&lt;&lt;1|1];&#125;void Add(ll k,ll l,ll r,ll v)&#123; add[k]+=v; sum[k]+=v*(r-l+1);&#125;void pushdown(ll k,ll l,ll r,ll mid)&#123; if(!add[k])return; Add(k&lt;&lt;1,l,mid,add[k]); Add(k&lt;&lt;1|1,mid+1,r,add[k]); add[k]=0;&#125;ll query_sum(ll k,ll l,ll r,ll x,ll y)&#123; if(l&gt;=x&amp;&amp;r&lt;=y)return sum[k]; ll mid=(l+r)&gt;&gt;1,res=0; pushdown(k,l,r,mid); if(x&lt;=mid)res+=query_sum(k&lt;&lt;1,l,mid,x,y); if(y&gt;mid)res+=query_sum(k&lt;&lt;1|1,mid+1,r,x,y); return res;&#125;void change(ll k,ll l,ll r,ll x,ll y,ll v)&#123; if(l&gt;=x&amp;&amp;r&lt;=y)&#123; Add(k,l,r,v); return; &#125; ll mid=(l+r)&gt;&gt;1; pushdown(k,l,r,mid); if(x&lt;=mid)change(k&lt;&lt;1,l,mid,x,y,v); if(y&gt;mid)change(k&lt;&lt;1|1,mid+1,r,x,y,v); sum[k]=sum[k&lt;&lt;1]+sum[k&lt;&lt;1|1];&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); build(1,1,n); for(int i=1;i&lt;=m;i++)&#123; scanf("%lld",&amp;k); switch(k)&#123; case 1:&#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;v); change(1,1,n,l,r,v); break; &#125; case 2:&#123; scanf("%lld%lld",&amp;l,&amp;r); printf("%lld\n",query_sum(1,1,n,l,r)); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1195 口袋的天空]]></title>
    <url>%2FLuogu_P1195%2F</url>
    <content type="text"><![CDATA[题目背景小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。 有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。 题目描述给你云朵的个数 $N$ ，再给你 $M$ 个关系，表示哪些云朵可以连在一起。 现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。 输入输出格式输入格式： 每组测试数据的第一行有三个数 $N,M,K(1≤N≤1000,1≤M≤10000,1≤K≤10)$ 。 接下来M个数每行三个数X,Y,L表示X云和Y云可以通过L的代价连在一起。$(1\le X,Y\le N,0\le L\le 10000)$ $30%$ 的数据 $N\le 100,M\le 1000$ 输出格式： 对每组数据输出一行，仅有一个整数，表示最小的代价。 如果怎么连都连不出 $K$ 个棉花糖，请输出’ $No Answer$ ‘。 输入输出样例输入样例#1： 123 1 21 2 1 输出样例#1： 11 题解怎么会有这么裸的模板题。。。还是绿题。。。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,k,father[1005],t,ans;struct Edge&#123; int x,y,dis;&#125;edge[10005];bool cmp(Edge x,Edge y)&#123; return x.dis&lt;y.dis;&#125;int find(int x)&#123; if(father[x]!=x)father[x]=find(father[x]); return father[x];&#125;void unionn(int x,int y,int dis)&#123; int a=find(x),b=find(y); father[a]=b; t--; ans+=dis;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); if(m&lt;n-k)&#123; printf("No Answer"); return 0; &#125; t=n; for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].dis); sort(edge+1,edge+m+1,cmp); for(int i=1;i&lt;=n;i++)father[i]=i; for(int i=1;i&lt;=m;i++)&#123; if(find(edge[i].x)!=find(edge[i].y))unionn(edge[i].x,edge[i].y,edge[i].dis); if(t==k)break; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老婆合集]]></title>
    <url>%2FWife%2F</url>
    <content type="text"><![CDATA[你可以选择无视这个文章 老婆列表 图片 我想说 血小板 我要太阳我的细胞 御坂美琴 你指尖… $Rachel·Gardner$ Ray快来打我我爱她 小鸟游六花 邪王真眼赛高！ 桐崎千棘 自古金发多傲娇 小野寺小咲 …渣乐 白 白，来跟我玩♂游♂戏吧 休比 休比太太太太太太可爱了 吉普莉尔 我来帮忙按摩吧⁄(⁄⁄•⁄ω⁄•⁄⁄)⁄ $Ruby\;Rose$ 我也想要把新月玫瑰Ruby帅炸！ $Weiss\;Schnee$ 听说直男克傲娇 $Blake\;Belladonna$ 我爱猫娘！ $Yang\;Xiao\;Long$ 杨姐嫁我 筒隐月子 面瘫什么的，斯巴拉西 小豆梓 强制傲娇…真是个神奇的属性 牧濑红莉栖 $El\;psy\;congroo$ 比企谷小町 就算不结婚，有妹妹不就好了吗？——大老师 雪之下雪乃 $QAQ$ 雪乃太好看了 由比滨结衣 团子真的好可爱 戸塚彩加 但是，是男的。 川崎沙希 蓝发傲娇真好 一色彩羽 喜闻乐见的小妖精 阿斯托尔福 可惜也是个男的 古莉 虽然是个 $baka$ 但是我喜欢图是真的少啊 蓝野亚久亚 蓝发 $+$ 兄控妹妹我轩你啊 $($ 去世 图怎么可以少成这样… 夜刀神十香 本子香 $($ 大雾 四糸乃 大哥哥这里有糖吃 五河琴里 你再傲娇试试 $?$ $($ 摘头巾 崇宮真那 又是个重度兄控的妹妹(ﾉﾟ∀ﾟ)ﾉ 时崎狂三 狂三别打我 诱宵美九 百合多好啊 $($ 痴笑 鸢一折纸 折纸大师，受我一拜 八舞耶倶矢 幸运 $E$ $($ 大雾 中野一花 我全都要！ 中野二乃 我全都要！ 中野三玖 我全都要！ 中野四叶 我全都要！ 中野五月 我全都要！ 利姆鲁 利姆鲁对我一心一意 $Saber$ $\color{gold}{吾王剑锋所指}$$\color{gold}{我等心之所向}$]]></content>
      <tags>
        <tag>二次元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P2141 珠心算测验]]></title>
    <url>%2FLuogu_P2141%2F</url>
    <content type="text"><![CDATA[题目描述珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。 某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？ 最近老师出了一些测验题，请你帮忙求出答案。 $($ 本题目为 $2014NOIP$ 普及 $T1)$ 输入输出格式输入格式： 共两行，第一行包含一个整数 $n$ ，表示测试题中给出的正整数个数。 第二行有 $n$ 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。 输出格式： 一个整数，表示测验题答案。 输入输出样例输入样例#1： 1241 2 3 4 输出样例#1： 12 说明【样例说明】 由 $1+2=3$,$1+3=4$ ，故满足测试要求的答案为 $2$ 。 注意，加数和被加数必须是集合中的两个不同的数。 【数据说明】 对于 $100%$ 的数据， $3\leq n\leq 100$ ，测验题给出的正整数大小不超过 $10000$ 。 题解本蒟蒻的第一个题解。。。 这道题其实很简单。。。 代码1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int a[101],n,ans;bool t[20001];//t[i]表示i这个数是否能由集合中的两个数相加而成int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) t[a[i]+a[j]]=true; for(int i=1;i&lt;=n;i++) ans+=t[a[i]]; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>暴力</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[喜报！]]></title>
    <url>%2FFirst_article%2F</url>
    <content type="text"><![CDATA[在本蒟蒻的不懈努力下…这个博客也算是勉强搭成了，花了好久…感谢网上各位大佬帮助$qwq$]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
